# COBOL→Java変換

## 学習目標
- 既存COBOLプログラムをGitHub CopilotでJavaコードに変換する体験ができる
- レガシーコードのビジネスロジックを理解し、コメントやテスト生成をAIに依頼できる

---

## 事前準備
1. **Windows + VS Code** を使用
2. **GitHub Copilot Agent Mode**が有効
3. ワークスペース直下の `legacy/` フォルダに [checkerr.cbl](https://www.ibm.com/docs/ja/db2/11.5.x?topic=SSEPGG_11.5.0/com.ibm.db2.luw.apdv.sample.doc/doc/cobol/s-checkerr-cbl.htm) をダウンロードして保存
4. Java関連ファイルは `src/` フォルダ以下に作成してください（GitHub Copilotに依頼して自動生成する流れを推奨）

---

## ラボ1 — COBOLコードをJavaに翻訳してみよう

### なぜ？
COBOLからJavaへの変換はモダナイゼーションの代表的な作業です。AIの支援で効率化できます。

### プロンプト例
```
このコードを Java に翻訳することはできますか? #file:legacy/checkerr.cbl
```
```
このコードを Java に翻訳してください。#file:legacy/checkerr.cbl
```

> **注意:**  
> COBOLからJavaへの変換は自動化しても、初回生成コードが完全ではない場合があります。構文やロジックの違い、仕様の解釈ミスなどにより、生成されたJavaコードは何度か修正・改善（イテレーション）が必要になることがあります。  
> 修正方法としては、AIに「修正してください」などのプロンプトで丸投げすることもできますし、自分でコードを確認して手動で修正することも可能です。状況に応じて使い分けてください。

---

## ラボ2 — コードにコメントを追加してみよう

### なぜ？
AIにコメント追加を依頼することで、コードの理解が深まります。

### プロンプト例
```
この部分にコメントを追加してください
```
（該当箇所を選択して実行）

---

## ラボ3 — ビジネスロジックの説明をAIに依頼しよう

### なぜ？
COBOLやJavaのビジネスロジックをAIに説明させることで、仕様理解が容易になります。

### プロンプト例
```
このコードのビジネスロジックを説明してください
```
（該当箇所を選択して実行）

---

## ラボ4 — ユニットテストを自動生成してみよう

### なぜ？
AIによるテスト生成で、品質向上とテスト自動化の体験ができます。

### プロンプト例
```
#file:<生成されたJavaファイル> このクラスに対するユニットテストを生成してください
```

> **注意:**  
> 生成されたテストコードは、元のビジネスロジックや仕様を正しくカバーしていない場合があります。テストケースの網羅性や動作確認のため、テストコードも繰り返し修正（イテレーション）することが重要です。  
> 修正方法としては、AIに「修正してください」などのプロンプトで丸投げすることもできますし、自分でコードを確認して手動で修正することも可能です。状況に応じて使い分けてください。
> また、GitHub Copilot Agent Modeはユニットテストを生成するだけでなく、「テストを実行しますか？」等と確認してくる場合があります。もしAIが自動で提案しない場合は、「テストを実行してください」などのプロンプトでAIに依頼することもできます。

---

## チェックリスト
- [ ] checkerr.cblをダウンロードし、ワークスペースに追加した
- [ ] COBOL→Java変換プロンプトを実行した
- [ ] コメント追加プロンプトを実行した
- [ ] ビジネスロジック説明プロンプトを実行した
- [ ] ユニットテスト生成プロンプトを実行した

---


## まとめ
- GitHub Copilotを活用することで、COBOLからJavaへの変換や理解・テスト生成が効率化できます
- コメントやビジネスロジックの説明、テスト生成はモダナイゼーションの重要なステップです
- 他のCOBOLファイルや大規模コードにも応用できます
- 生成されたコードやテストは、AIに丸投げで修正依頼することも、自分で内容を確認して修正することもできます
- 丸投げと手動修正を使い分けることで、効率的に品質を高めることができます

## 次のステップ
- ユニットテストがすべて成功しても、「そのテスト自体が正しいか」「本当に現状の振る舞いを網羅できているか」は保証されません。  
- 特にレガシーコードの移行では、仕様が不明確な場合やテストケースが不十分な場合があります。  
- そこで次のラボ（[8-characterization-testing.md](8-characterization-testing.md)）では、「現時点の振る舞い」をテストで固定し、意図しない変更（回帰）を検出する“キャラクタリゼーションテスト”の考え方と実践方法を学びます。

## インストラクター向けノート
> **所要時間目安**
> - 60分