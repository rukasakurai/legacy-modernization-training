# キャラクタリゼーションテスト

レガシーシステムを生成AIで移行・リファクタリングする際、**キャラクタリゼーションテスト（characterization test）**は「仕様が不完全でも“現在の振る舞い”を守る」ための安全網です。既存システムの観察結果（入力→出力ペア）をベースラインとして固定し、その後の自動変換・最適化・リファクタリングによる意図しない挙動差（リグレッション）を検出します。本ラボでは、シンプルな既存 Java コードを題材に、この考え方を体験します。コード自体は単純ですが、あえて“ベースラインを固めてから書き換える”流れを踏むことで、より複雑なレガシー移行時のプロセスを縮図的に学べます。

---

## 学習目標
- キャラクタリゼーションテストの目的を説明できる
- 観察された振る舞い（ベースライン）をテストとして固定できる
- JUnitで入力→出力ペアをコード化できる

---

## 事前準備
1. **Windows + VS Code** を使用（本トレーニング標準環境）
2. **GitHub Copilot Agent Mode** を有効化
3. **JDK 21** がインストール済みであること
4. （任意）Maven プロジェクトとして進めたい場合は `mvn -v` で動作確認
5. VS Code で本ファイルを開き、ラボ手順に従う

---

## 対象となる「既存」コード（ベースライン化するコード）
以下を `src/main/java/legacy/SumCalculator.java` として配置すると仮定します（ファイルが無ければ後で作成）。

```java
public class SumCalculator {
	public int sum(int[] values) {
		int total = 0;
		for (int v : values) {
			total += v;
		}
		return total;
	}
}
```

この実装は「配列内全要素の合計を返す」という振る舞いを持っています。今後の変更（Stream API への書き換え等）前に、この振る舞いをベースラインとします。

---

## ラボ1 — 挙動の観察と記録
### 目的
現在の挙動を観察と記録して、ベースラインを洗い出す。
### 作業
1. 代表入力例を考える（例：`{1,2,3,4,5}`, 空配列, 負数混在 `{ -2, 3 }`）
2. 代表入力例で SumCalculator を実行し、出力を記録

---

## ラボ2 — ベースライン（観察結果）のテスト化
### 目的
“現在の正しさ”をコード（JUnitテスト）として固定する。
### 作業
1. `src/test/java/legacy/SumCalculatorTest.java` を作成
2. 最低3ケース（基本 / 空 / 負数混在）をテスト

---

## ラボ3 — GitHub Copilotでテスト拡張
### 目的
AI支援でテストケースの網羅性等を高める。
### 作業
1. GitHub Copilotに追加入力を提案してもらう（例: エッジケース）
2. SumCalculator の挙動を観察し、テストケースに追加

---

## インストラクター向けノート
> **所要時間目安**
> - 60分（参加者のJava経験等により変動）

